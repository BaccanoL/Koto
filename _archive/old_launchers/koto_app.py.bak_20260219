#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Koto æ¡Œé¢åº”ç”¨ - ç‹¬ç«‹çª—å£ç‰ˆæœ¬
ä½¿ç”¨ pywebview åˆ›å»ºåŸç”Ÿçª—å£ï¼ŒFlask ä½œä¸ºåç«¯
æ— ç»ˆç«¯ï¼Œå®Œå…¨ç‹¬ç«‹è¿è¡Œ
"""

import os
import sys
import threading
import time
import socket
from pathlib import Path
from datetime import datetime
import psutil
import faulthandler
import traceback

KOTO_HOST = "127.0.0.1"
KOTO_PORT = 5000
FALLBACK_PORT = 5001
STARTUP_TIMEOUT_SEC = 3  # å¿«é€Ÿå¯åŠ¨æ¨¡å¼ï¼š3ç§’è¶³å¤Ÿ

# è·å–åº”ç”¨æ ¹ç›®å½•å’Œèµ„æºç›®å½•
if getattr(sys, 'frozen', False):
    # PyInstalleræ‰“åŒ…åï¼š
    # - APP_ROOT: exeæ‰€åœ¨ç›®å½•ï¼ˆç”¨äºæŒä¹…åŒ–æ•°æ®ï¼šchats/ã€config/ã€workspace/ç­‰ï¼‰
    # - BUNDLE_DIR: ä¸´æ—¶è§£å‹ç›®å½•ï¼ˆç”¨äºbundledèµ„æºï¼šweb/ã€assets/ç­‰ï¼‰
    APP_ROOT = Path(sys.executable).parent
    BUNDLE_DIR = Path(sys._MEIPASS)
else:
    # å¼€å‘ç¯å¢ƒï¼šä¸¤è€…ç›¸åŒ
    APP_ROOT = Path(__file__).parent
    BUNDLE_DIR = APP_ROOT

os.chdir(str(APP_ROOT))
sys.path.insert(0, str(BUNDLE_DIR))  # ç¡®ä¿èƒ½æ‰¾åˆ°bundledçš„webæ¨¡å—

LOG_FILE = APP_ROOT / "logs" / "startup.log"
RUNTIME_LOG_FILE = APP_ROOT / "logs" / f"runtime_{datetime.now().strftime('%Y%m%d')}.log"

class DualOutput:
    """åŒæ—¶è¾“å‡ºåˆ°æ–‡ä»¶å’Œæ§åˆ¶å°"""
    def __init__(self, original_stream, log_file):
        self.original_stream = original_stream
        self.log_file = log_file
    
    def write(self, message):
        try:
            self.original_stream.write(message)
            self.original_stream.flush() # ç¡®ä¿æ§åˆ¶å°åŠæ—¶è¾“å‡º
            with open(self.log_file, "a", encoding="utf-8", errors="ignore") as f:
                f.write(message)
        except Exception:
            pass
            
    def flush(self):
        try:
            self.original_stream.flush()
        except:
            pass

def _redirect_output():
    """å°† stdout/stderr é‡å®šå‘åˆ°æ—¥å¿—æ–‡ä»¶"""
    try:
        RUNTIME_LOG_FILE.parent.mkdir(parents=True, exist_ok=True)
        # å†™å…¥åˆ†éš”ç¬¦
        with open(RUNTIME_LOG_FILE, "a", encoding="utf-8") as f:
            f.write(f"\n\n{'='*30} New Session {datetime.now()} {'='*30}\n")
        
        sys.stdout = DualOutput(sys.stdout, RUNTIME_LOG_FILE)
        sys.stderr = DualOutput(sys.stderr, RUNTIME_LOG_FILE)
        print(f"Log redirected to {RUNTIME_LOG_FILE}")
    except Exception as e:
        print(f"Failed to redirect output: {e}")

_redirect_output()

def _write_log(message: str):
    """å†™å…¥å¯åŠ¨æ—¥å¿—å¹¶åŒæ­¥æ‰“å°ï¼Œä¾¿äºå®šä½â€œæœªå“åº”â€åŸå› """
    try:
        LOG_FILE.parent.mkdir(parents=True, exist_ok=True)
        ts = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        line = f"[{ts}] {message}\n"
        with LOG_FILE.open("a", encoding="utf-8") as f:
            f.write(line)
        print(message)
    except Exception:
        # æ—¥å¿—å¤±è´¥ä¸åº”é˜»å¡å¯åŠ¨
        pass

def _dump_threads(label: str = "thread-dump"):
    """å°†å½“å‰è¿›ç¨‹çš„çº¿ç¨‹æ ˆå†™å…¥æ—¥å¿—ï¼Œæ–¹ä¾¿å®šä½å¡æ­»ä½ç½®"""
    try:
        with LOG_FILE.open("a", encoding="utf-8") as f:
            f.write(f"\n===== {label} {datetime.now().strftime('%Y-%m-%d %H:%M:%S')} =====\n")
            faulthandler.dump_traceback(file=f, all_threads=True)
    except Exception:
        traceback.print_exc()


def _terminate_stale_process_on_port(port: int, reason: str = "") -> bool:
    """å¦‚æœç«¯å£è¢«æœ¬æœº pythonw å ç”¨ä¸”æ— å¥åº·å“åº”ï¼Œå°è¯•ç»ˆæ­¢å¹¶é‡Šæ”¾ç«¯å£"""
    killed = False
    try:
        for conn in psutil.net_connections(kind="inet"):
            if conn.laddr and conn.laddr.port == port and conn.status == psutil.CONN_LISTEN:
                pid = conn.pid
                if not pid:
                    continue
                try:
                    proc = psutil.Process(pid)
                    cmdline = " ".join(proc.cmdline()).lower()
                    if "koto_app.py" in cmdline or "pythonw" in proc.name().lower():
                        _write_log(f"âš ï¸ ç»ˆæ­¢å ç”¨ {port} çš„è¿›ç¨‹ {pid}ï¼ˆ{reason}ï¼‰")
                        proc.kill() # Force kill
                        time.sleep(1)
                        killed = True
                except Exception as e:
                    pass
    except Exception as e:
        _write_log(f"âš ï¸ æ£€æŸ¥ç«¯å£å ç”¨å¤±è´¥: {e}")
    return killed

def _wait_for_port(host: str, port: int, timeout_sec: int) -> bool:
    """ç­‰å¾…ç«¯å£ç›‘å¬å°±ç»ª"""
    start = time.time()
    while time.time() - start < timeout_sec:
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(0.2)
            if sock.connect_ex((host, port)) == 0:
                sock.close()
                return True
            sock.close()
        except Exception:
            pass
        time.sleep(0.2)
    return False

def _check_http_ok(url: str) -> bool:
    """æ£€æŸ¥ HTTP æ˜¯å¦å¯è®¿é—®"""
    try:
        from urllib.request import urlopen, build_opener, ProxyHandler
        opener = build_opener(ProxyHandler({}))  # ç¦ç”¨ç³»ç»Ÿä»£ç†ï¼Œé¿å…è¢«æœ¬åœ°ä»£ç†åŠ«æŒè¯¯åˆ¤
        with opener.open(url, timeout=2) as resp:
            return resp.status == 200
    except Exception:
        return False

def ensure_directories():
    """ç¡®ä¿å¿…è¦çš„ç›®å½•å­˜åœ¨"""
    dirs = ['workspace', 'workspace/images', 'workspace/documents',
            'workspace/code', 'chats', 'logs', 'config']
    for d in dirs:
        (APP_ROOT / d).mkdir(exist_ok=True, parents=True)
    _write_log("âœ” ç›®å½•æ£€æŸ¥å®Œæˆ")

def check_config():
    """æ£€æŸ¥é…ç½®æ–‡ä»¶"""
    config_file = APP_ROOT / 'config' / 'gemini_config.env'
    if not config_file.exists():
        config_file.parent.mkdir(exist_ok=True, parents=True)
        config_file.write_text(
            "# Koto Configuration\n"
            "API_KEY=your_api_key_here\n"
            "GEMINI_API_KEY=your_api_key_here\n"
        )
        _write_log("âš ï¸ æœªæ£€æµ‹åˆ° gemini_config.envï¼Œå·²ç”Ÿæˆå ä½æ–‡ä»¶")
    else:
        _write_log("âœ” é…ç½®æ–‡ä»¶å­˜åœ¨")

def ensure_dependencies():
    """æ£€æŸ¥æ¡Œé¢ä¾èµ–ï¼Œé¿å…æ¯æ¬¡å¯åŠ¨éƒ½æ‰§è¡Œå®‰è£…"""
    missing = []
    try:
        import webview  # noqa: F401
    except ImportError:
        missing.append("pywebview")

    try:
        from pystray import Icon  # noqa: F401
        from PIL import Image  # noqa: F401
    except ImportError:
        missing.append("pystray/pillow")

    if missing:
        auto_install = os.environ.get("KOTO_AUTO_INSTALL_DEPS", "0") == "1"
        if auto_install:
            os.system(f'"{sys.executable}" -m pip install pywebview pystray pillow --quiet')
            _write_log(f"âš ï¸ è‡ªåŠ¨å®‰è£…ç¼ºå¤±ä¾èµ–: {', '.join(missing)}")
            return True
        else:
            _write_log("âš ï¸ ç¼ºå°‘ä¾èµ–: " + ", ".join(missing))
            _write_log("è¯·å…ˆæ‰§è¡Œ: pip install pywebview pystray pillow")
            return False
    _write_log("âœ” å…³é”®ä¾èµ–å°±ç»ª")
    return True

class VoiceAPI:
    """è¯­éŸ³è¯†åˆ« API - æä¾›ç»™å‰ç«¯è°ƒç”¨
    æ³¨æ„ï¼šå®é™…é€šè¿‡ Flask REST API å®ç°
    è¿™ä¸ªç±»ä»…ä½œä¸ºå ä½ç¬¦ï¼Œä¿æŒå…¼å®¹æ€§
    """
    def __init__(self):
        pass
    
    def get_available_engines(self):
        """è¿”å›æ‰€æœ‰å¯ç”¨å¼•æ“ï¼ˆå ä½ç¬¦ï¼‰"""
        try:
            from web.voice_recognition import get_voice_recognizer
            recognizer = get_voice_recognizer()
            return recognizer.list_available_engines()
        except:
            return []


class WindowAPI:
    """çª—å£æ§åˆ¶API - æä¾›ç»™å‰ç«¯è°ƒç”¨"""
    def __init__(self, window):
        self.window = window
        self.is_mini_mode = False
        self.full_size = (1200, 800)
        self.full_pos = None
        self.mini_size = (320, 480)  # é€‚åˆé«˜åˆ†è¾¨ç‡å±å¹•çš„è¿·ä½ å°ºå¯¸
    
    def switch_to_mini(self):
        """åˆ‡æ¢åˆ°è¿·ä½ æ¨¡å¼ - å›ºå®šåœ¨å±å¹•å³ä¸‹è§’"""
        if self.is_mini_mode:
            return {"success": True, "mode": "mini"}
        
        try:
            import ctypes
            user32 = ctypes.windll.user32
            # ä½¿ç”¨çœŸå®å±å¹•åˆ†è¾¨ç‡ï¼ˆè€ƒè™‘DPIç¼©æ”¾ï¼‰
            user32.SetProcessDPIAware()
            screen_w = user32.GetSystemMetrics(0)
            screen_h = user32.GetSystemMetrics(1)
            
            # ä¿å­˜å½“å‰ä½ç½®å’Œå¤§å°
            self.full_size = (self.window.width, self.window.height)
            
            # è¿·ä½ çª—å£ï¼šå›ºå®šå±å¹•å³ä¾§ï¼ˆå‚ç›´å±…ä¸­ï¼‰
            mini_w, mini_h = self.mini_size
            x = screen_w - mini_w - 20
            y = max(20, (screen_h - mini_h) // 2)
            
            # å…ˆç§»åŠ¨å†è°ƒæ•´å¤§å°ï¼Œç¡®ä¿ä½ç½®æ­£ç¡®
            self.window.move(x, y)
            self.window.resize(mini_w, mini_h)
            self.window.on_top = True
            self.is_mini_mode = True
            
            # åŠ è½½è¿·ä½ UI
            self.window.load_url('http://127.0.0.1:5000/mini')
            
            return {"success": True, "mode": "mini", "size": [mini_w, mini_h], "pos": [x, y]}
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    def switch_to_full(self):
        """åˆ‡æ¢åˆ°å®Œæ•´æ¨¡å¼"""
        if not self.is_mini_mode:
            return {"success": True, "mode": "full"}
        
        try:
            import ctypes
            user32 = ctypes.windll.user32
            screen_w = user32.GetSystemMetrics(0)
            screen_h = user32.GetSystemMetrics(1)
            
            # æ¢å¤å®Œæ•´æ¨¡å¼
            full_w, full_h = self.full_size
            x = (screen_w - full_w) // 2
            y = (screen_h - full_h) // 2
            
            self.window.on_top = False
            self.window.resize(full_w, full_h)
            self.window.move(x, y)
            self.is_mini_mode = False
            
            # åŠ è½½å®Œæ•´UI
            self.window.load_url('http://127.0.0.1:5000')
            
            return {"success": True, "mode": "full"}
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    def get_mode(self):
        """è·å–å½“å‰æ¨¡å¼"""
        return {"mode": "mini" if self.is_mini_mode else "full"}
    
    def minimize(self):
        """æœ€å°åŒ–çª—å£"""
        self.window.minimize()
    
    def maximize(self):
        """æœ€å¤§åŒ–/è¿˜åŸçª—å£"""
        try:
            # pywebviewæ²¡æœ‰ç›´æ¥çš„maximizeï¼Œç”¨toggle_fullscreenæ›¿ä»£
            self.window.toggle_fullscreen()
        except:
            pass
    
    def close(self):
        """å…³é—­çª—å£"""
        self.window.destroy()


def _pre_check_syntax(filepath: str):
    """
    é¢„æ£€æŸ¥ Python æ–‡ä»¶è¯­æ³•ï¼Œåœ¨ import ä¹‹å‰å‘ç°é—®é¢˜ã€‚
    è¿”å› (True/False, error_message)
    """
    import ast
    try:
        with open(filepath, 'r', encoding='utf-8') as f:
            source = f.read()
        ast.parse(source, filename=filepath)
        return True, None
    except SyntaxError as e:
        error_msg = f"{e.msg} ({os.path.basename(filepath)}, line {e.lineno})"
        return False, error_msg
    except Exception as e:
        return False, str(e)


def _auto_fix_syntax(filepath: str, error_msg: str) -> bool:
    """
    å°è¯•è‡ªåŠ¨ä¿®å¤å¸¸è§çš„è¯­æ³•é”™è¯¯ã€‚
    å½“å‰æ”¯æŒä¿®å¤:
    1. f-string è¡¨è¾¾å¼ä¸­çš„åæ–œæ  (Python < 3.12)
    2. æœªé—­åˆçš„æ‹¬å·/å¼•å·ï¼ˆç®€å•æƒ…å†µï¼‰
    
    è¿”å› True å¦‚æœåšäº†ä¿®æ”¹ï¼ŒFalse å¦‚æœæ— æ³•ä¿®å¤ã€‚
    """
    import re as re_mod
    import shutil
    
    try:
        with open(filepath, 'r', encoding='utf-8') as f:
            lines = f.readlines()
    except Exception:
        return False
    
    fixed = False
    
    # ä¿®å¤ç±»å‹ 1: f-string è¡¨è¾¾å¼ä¸­çš„åæ–œæ 
    # é”™è¯¯ä¿¡æ¯å½¢å¦‚: "f-string expression part cannot include a backslash"
    if 'backslash' in error_msg.lower() and 'f-string' in error_msg.lower():
        _write_log("ğŸ”§ æ£€æµ‹åˆ° f-string åæ–œæ é—®é¢˜ï¼Œå°è¯•è‡ªåŠ¨ä¿®å¤...")
        
        # æå–é”™è¯¯è¡Œå·
        line_match = re_mod.search(r'line\s+(\d+)', error_msg)
        if line_match:
            error_line = int(line_match.group(1)) - 1  # 0-indexed
            if 0 <= error_line < len(lines):
                original_line = lines[error_line]
                
                # ç­–ç•¥: å°†åŒ…å« \\n çš„ f-string json.dumps è¡¨è¾¾å¼æ‹†åˆ†
                # ä¾‹å¦‚: yield f"data: {json.dumps({'message': f'xx\\nxx'})}\n\n"
                # ä¿®å¤ä¸º: å…ˆæ„å»º msg å˜é‡ï¼Œå†ä½¿ç”¨
                if '\\\\n' in original_line or "\\\\n" in original_line:
                    # åœ¨å½“å‰è¡Œä¹‹å‰æ’å…¥ä¸€ä¸ªå˜é‡å®šä¹‰
                    indent = len(original_line) - len(original_line.lstrip())
                    indent_str = ' ' * indent
                    
                    # æå– json.dumps å†…çš„ f-string å¹¶æ›¿æ¢ \\n ä¸ºæ¢è¡Œå˜é‡
                    new_line = original_line.replace('\\\\n', "' + chr(10) + '")
                    
                    if new_line != original_line:
                        lines[error_line] = new_line
                        fixed = True
                        _write_log(f"  ä¿®å¤ç¬¬ {error_line + 1} è¡Œ: æ›¿æ¢ f-string ä¸­çš„åæ–œæ ")
    
    if fixed:
        # å¤‡ä»½åŸæ–‡ä»¶
        backup_path = filepath + '.bak'
        try:
            shutil.copy2(filepath, backup_path)
            _write_log(f"  å¤‡ä»½åŸæ–‡ä»¶åˆ° {os.path.basename(backup_path)}")
        except Exception:
            pass
        
        # å†™å›ä¿®å¤åçš„æ–‡ä»¶
        try:
            with open(filepath, 'w', encoding='utf-8') as f:
                f.writelines(lines)
            _write_log("âœ… è¯­æ³•ä¿®å¤å·²å†™å…¥æ–‡ä»¶")
            return True
        except Exception as e:
            _write_log(f"âŒ å†™å…¥ä¿®å¤æ–‡ä»¶å¤±è´¥: {e}")
            return False
    
    return False


def start_flask_server():
    """åœ¨åå°çº¿ç¨‹å¯åŠ¨ Flask æœåŠ¡å™¨ï¼ˆå¸¦é¢„æ£€æŸ¥å’Œé”™è¯¯æ¢å¤ï¼‰"""
    import logging
    log = logging.getLogger('werkzeug')
    log.setLevel(logging.ERROR)

    health_url = f"http://{KOTO_HOST}:{KOTO_PORT}/api/health"

    # å¦‚æœç«¯å£å·²è¢«å ç”¨ï¼Œå…ˆæ ¡éªŒæ˜¯å¦çœŸçš„æ˜¯å¯ç”¨çš„ Koto æœåŠ¡
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(0.2)
        if sock.connect_ex((KOTO_HOST, KOTO_PORT)) == 0:
            sock.close()
            if _check_http_ok(health_url):
                _write_log(f"â„¹ï¸ æ£€æµ‹åˆ° {KOTO_HOST}:{KOTO_PORT} å·²åœ¨è¿è¡Œï¼Œå¥åº·æ£€æŸ¥é€šè¿‡ï¼Œè·³è¿‡å†…ç½®æœåŠ¡å¯åŠ¨")
                return {"started": False, "already_running": True}
            else:
                _write_log(f"âš ï¸ {KOTO_HOST}:{KOTO_PORT} è¢«å ç”¨ä½†å¥åº·æ£€æŸ¥å¤±è´¥ï¼Œå°è¯•æ¸…ç†å ç”¨è¿›ç¨‹")
                cleaned = _terminate_stale_process_on_port(KOTO_PORT, reason="health timeout")
                if cleaned:
                    _write_log("â„¹ï¸ å·²æ¸…ç†å ç”¨è¿›ç¨‹ï¼Œç»§ç»­å¯åŠ¨å†…ç½®æœåŠ¡")
                else:
                    _write_log(f"âš ï¸ æ¸…ç†å¤±è´¥ï¼Œå°†åˆ‡æ¢å¤‡ç”¨ç«¯å£ {FALLBACK_PORT}")
                    return {"started": False, "already_running": False, "needs_fallback": True}
        sock.close()
    except Exception:
        pass

    _server_error = [None]  # ç”¨åˆ—è¡¨å­˜å‚¨ï¼Œæ–¹ä¾¿åœ¨é—­åŒ…ä¸­ä¿®æ”¹

    def run_server():
        try:
            # â”€â”€â”€â”€â”€â”€â”€â”€ é¢„å¯åŠ¨è¯­æ³•æ£€æŸ¥ â”€â”€â”€â”€â”€â”€â”€â”€
            # åœ¨å¯¼å…¥ app.py ä¹‹å‰å…ˆæ£€æŸ¥è¯­æ³•ï¼Œé¿å…å¤§æ–‡ä»¶å¯¼å…¥æ—¶å´©æºƒ
            app_file = os.path.join(str(APP_ROOT), "web", "app.py")
            if os.path.exists(app_file):
                syntax_ok, syntax_err = _pre_check_syntax(app_file)
                if not syntax_ok:
                    _write_log(f"âŒ app.py è¯­æ³•æ£€æŸ¥å¤±è´¥: {syntax_err}")
                    # å°è¯•è‡ªåŠ¨ä¿®å¤
                    fixed = _auto_fix_syntax(app_file, syntax_err)
                    if fixed:
                        _write_log("âœ… å·²è‡ªåŠ¨ä¿®å¤è¯­æ³•é”™è¯¯ï¼Œé‡æ–°æ£€æŸ¥...")
                        syntax_ok2, syntax_err2 = _pre_check_syntax(app_file)
                        if not syntax_ok2:
                            _write_log(f"âŒ è‡ªåŠ¨ä¿®å¤åä»æœ‰è¯­æ³•é”™è¯¯: {syntax_err2}")
                            _server_error[0] = syntax_err2
                            _start_fallback_server(syntax_err2, port=KOTO_PORT)
                            return
                        _write_log("âœ… è¯­æ³•ä¿®å¤æˆåŠŸï¼")
                    else:
                        _server_error[0] = syntax_err
                        _start_fallback_server(syntax_err, port=KOTO_PORT)
                        return
            
            # â”€â”€â”€â”€â”€â”€â”€â”€ æ­£å¼å¯åŠ¨ Flask â”€â”€â”€â”€â”€â”€â”€â”€
            from web.app import app
            app.run(host=KOTO_HOST, port=KOTO_PORT, debug=False, use_reloader=False, threaded=True)
        except SyntaxError as e:
            error_msg = f"è¯­æ³•é”™è¯¯ ({e.filename}, ç¬¬{e.lineno}è¡Œ): {e.msg}"
            _server_error[0] = error_msg
            _write_log(f"âŒ Flask æœåŠ¡å¯åŠ¨å¤±è´¥(è¯­æ³•): {error_msg}")
            _start_fallback_server(error_msg, port=KOTO_PORT)
        except Exception as e:
            _server_error[0] = str(e)
            _write_log(f"âŒ Flask æœåŠ¡å¯åŠ¨å¤±è´¥: {e}")
            # å¯åŠ¨ä¸€ä¸ªæœ€å°çš„é”™è¯¯æç¤ºæœåŠ¡å™¨
            _start_fallback_server(str(e), port=KOTO_PORT)

    server_thread = threading.Thread(target=run_server, daemon=True)
    server_thread.start()
    
    # å¿«é€Ÿç­‰å¾…æœåŠ¡å™¨å¯åŠ¨ï¼ˆæœ€å¤š2ç§’ï¼‰
    _wait_for_port(KOTO_HOST, KOTO_PORT, 2)
    _write_log("âœ” Flask åå°çº¿ç¨‹å·²å¯åŠ¨")
    return {"started": True, "already_running": False, "thread": server_thread, "error": _server_error[0]}


def _start_fallback_server(error_msg: str, port: int = KOTO_PORT):
    """å½“ä¸» Flask åº”ç”¨åŠ è½½å¤±è´¥æ—¶ï¼Œå¯åŠ¨ä¸€ä¸ªå¸¦è¯Šæ–­èƒ½åŠ›çš„é”™è¯¯æ¢å¤æœåŠ¡å™¨"""
    try:
        from http.server import HTTPServer, BaseHTTPRequestHandler
        from urllib.parse import urlparse, parse_qs
        import html
        import json as json_mod

        safe_error = html.escape(error_msg)

        class FallbackHandler(BaseHTTPRequestHandler):
            def do_GET(self):
                parsed = urlparse(self.path)
                
                # API: è·å–è¯Šæ–­ä¿¡æ¯
                if parsed.path == '/api/diagnose':
                    self._handle_diagnose()
                    return
                
                # API: å°è¯•é‡å¯
                if parsed.path == '/api/retry':
                    self._handle_retry()
                    return
                
                # ä¸»é¡µé¢
                self.send_response(200)
                self.send_header('Content-Type', 'text/html; charset=utf-8')
                self.end_headers()
                page = self._build_error_page(safe_error)
                self.wfile.write(page.encode('utf-8'))
            
            def do_POST(self):
                if self.path == '/api/retry':
                    self._handle_retry()
                    return
                self.send_response(404)
                self.end_headers()
            
            def _handle_diagnose(self):
                """è¯Šæ–­å½“å‰ç³»ç»ŸçŠ¶æ€"""
                app_file = os.path.join(str(APP_ROOT), "web", "app.py")
                info = {
                    "python_version": sys.version,
                    "app_file_exists": os.path.exists(app_file),
                    "app_file_size": os.path.getsize(app_file) if os.path.exists(app_file) else 0,
                    "error": error_msg,
                }
                # è¯­æ³•æ£€æŸ¥
                if os.path.exists(app_file):
                    ok, err = _pre_check_syntax(app_file)
                    info["syntax_ok"] = ok
                    info["syntax_error"] = err
                
                self.send_response(200)
                self.send_header('Content-Type', 'application/json; charset=utf-8')
                self.end_headers()
                self.wfile.write(json_mod.dumps(info, ensure_ascii=False).encode('utf-8'))
            
            def _handle_retry(self):
                """å°è¯•é‡æ–°å¯åŠ¨ä¸»åº”ç”¨"""
                result = {"success": False, "message": ""}
                app_file = os.path.join(str(APP_ROOT), "web", "app.py")
                
                # 1. å…ˆæ£€æŸ¥è¯­æ³•
                ok, err = _pre_check_syntax(app_file)
                if not ok:
                    # å°è¯•è‡ªåŠ¨ä¿®å¤
                    fixed = _auto_fix_syntax(app_file, err)
                    if fixed:
                        ok2, err2 = _pre_check_syntax(app_file)
                        if ok2:
                            result["message"] = "è¯­æ³•å·²è‡ªåŠ¨ä¿®å¤ï¼æ­£åœ¨é‡å¯ç¨‹åº..."
                            result["success"] = True
                            result["action"] = "restart"
                        else:
                            result["message"] = f"è‡ªåŠ¨ä¿®å¤å¤±è´¥ï¼Œä»æœ‰é”™è¯¯: {err2}"
                    else:
                        result["message"] = f"æ— æ³•è‡ªåŠ¨ä¿®å¤: {err}"
                else:
                    result["message"] = "è¯­æ³•æ£€æŸ¥é€šè¿‡ï¼æ­£åœ¨é‡å¯ç¨‹åº..."
                    result["success"] = True
                    result["action"] = "restart"
                
                self.send_response(200)
                self.send_header('Content-Type', 'application/json; charset=utf-8')
                self.end_headers()
                self.wfile.write(json_mod.dumps(result, ensure_ascii=False).encode('utf-8'))
                
                # å¦‚æœä¿®å¤æˆåŠŸï¼Œé‡å¯æ•´ä¸ªè¿›ç¨‹
                if result.get("success"):
                    _write_log("ğŸ”„ è¯­æ³•ä¿®å¤æˆåŠŸï¼Œå‡†å¤‡é‡å¯è¿›ç¨‹...")
                    def _do_restart():
                        time.sleep(1)
                        _write_log("ğŸ”„ æ­£åœ¨é‡å¯ Koto...")
                        os.execv(sys.executable, [sys.executable] + sys.argv)
                    threading.Thread(target=_do_restart, daemon=True).start()
            
            def _build_error_page(self, safe_err):
                return (
                    '<!DOCTYPE html><html><head><meta charset="utf-8">'
                    '<title>Koto - å¯åŠ¨ä¿®å¤</title>'
                    '<style>'
                    '*{box-sizing:border-box}'
                    'body{font-family:system-ui,-apple-system,sans-serif;display:flex;align-items:center;'
                    'justify-content:center;min-height:100vh;margin:0;background:#0f0f1a;color:#e0e0e0}'
                    '.card{background:#1a1a2e;border-radius:20px;padding:48px;max-width:680px;width:90%;'
                    'box-shadow:0 12px 48px rgba(0,0,0,.4)}'
                    'h1{color:#ff6b6b;margin:0 0 8px;font-size:28px;text-align:center}'
                    '.subtitle{color:#888;text-align:center;margin-bottom:24px;font-size:14px}'
                    '.error-box{background:#0d1b2a;border:1px solid #1b2838;border-radius:12px;'
                    'padding:20px;margin:20px 0;font-family:"Cascadia Code","Fira Code",monospace;'
                    'font-size:13px;word-break:break-all;max-height:160px;overflow:auto;'
                    'line-height:1.6;color:#ffd93d}'
                    '.actions{display:flex;gap:12px;margin:24px 0;flex-wrap:wrap}'
                    '.btn{flex:1;padding:14px 24px;border:none;border-radius:12px;font-size:15px;'
                    'font-weight:600;cursor:pointer;transition:all .2s;min-width:140px;text-align:center}'
                    '.btn-primary{background:linear-gradient(135deg,#4361ee,#3a0ca3);color:#fff}'
                    '.btn-primary:hover{transform:translateY(-2px);box-shadow:0 6px 20px rgba(67,97,238,.4)}'
                    '.btn-secondary{background:#1b2838;color:#4fc3f7;border:1px solid #2a3a4a}'
                    '.btn-secondary:hover{background:#243447}'
                    '.btn:disabled{opacity:.5;cursor:not-allowed;transform:none}'
                    '.status{padding:16px;border-radius:12px;margin:16px 0;font-size:14px;'
                    'display:none;line-height:1.8}'
                    '.status.show{display:block}'
                    '.status.success{background:#1a3a2a;border:1px solid #2d6a4f;color:#52b788}'
                    '.status.error{background:#3a1a1a;border:1px solid #6a2d2d;color:#ff6b6b}'
                    '.status.info{background:#1a2a3a;border:1px solid #2d4a6a;color:#4fc3f7}'
                    '.tips{margin-top:20px;padding:20px;background:#16213e;border-radius:12px}'
                    '.tips h3{margin:0 0 12px;font-size:15px;color:#aaa}'
                    '.tips ul{margin:0;padding-left:20px;line-height:2.2}'
                    '.tips li{font-size:13px;color:#999}'
                    '.tips code{background:#0d1b2a;padding:2px 8px;border-radius:4px;font-size:12px;color:#4fc3f7}'
                    '.spinner{display:inline-block;width:16px;height:16px;border:2px solid #fff3;'
                    'border-top-color:#fff;border-radius:50%;animation:spin .6s linear infinite;'
                    'vertical-align:middle;margin-right:8px}'
                    '@keyframes spin{to{transform:rotate(360deg)}}'
                    '.footer{text-align:center;margin-top:24px;font-size:12px;color:#555}'
                    '</style></head><body>'
                    '<div class="card">'
                    '<h1>âš ï¸ Koto å¯åŠ¨é‡åˆ°é—®é¢˜</h1>'
                    '<p class="subtitle">åº”ç”¨åŠ è½½è¿‡ç¨‹ä¸­å‡ºç°é”™è¯¯ï¼Œå¯å°è¯•è‡ªåŠ¨ä¿®å¤</p>'
                    f'<div class="error-box">{safe_err}</div>'
                    '<div id="status" class="status"></div>'
                    '<div class="actions">'
                    '<button class="btn btn-primary" id="retryBtn" onclick="handleRetry()">'
                    'ğŸ”§ è‡ªåŠ¨ä¿®å¤å¹¶é‡å¯</button>'
                    '<button class="btn btn-secondary" id="diagnoseBtn" onclick="handleDiagnose()">'
                    'ğŸ” è¯Šæ–­æ£€æŸ¥</button>'
                    '</div>'
                    '<div class="tips">'
                    '<h3>ğŸ’¡ æ‰‹åŠ¨æ’æŸ¥æç¤º</h3>'
                    '<ul>'
                    '<li>ğŸ”‘ æ£€æŸ¥ <code>config/gemini_config.env</code> ä¸­çš„ API å¯†é’¥</li>'
                    '<li>ğŸ“¦ è¿è¡Œ <code>pip install -r requirements.txt</code></li>'
                    '<li>ğŸ”„ å…³é—­åé‡æ–°è¿è¡Œ <code>RunSource.bat</code></li>'
                    '<li>ğŸ“‹ æŸ¥çœ‹ <code>logs/startup.log</code> è·å–è¯¦ç»†æ—¥å¿—</li>'
                    '</ul></div>'
                    '<div class="footer">Koto v2.0 | é”™è¯¯æ¢å¤æ¨¡å¼</div>'
                    '</div>'
                    '<script>'
                    'const statusEl=document.getElementById("status");'
                    'const retryBtn=document.getElementById("retryBtn");'
                    'const diagnoseBtn=document.getElementById("diagnoseBtn");'
                    'function showStatus(msg,type){'
                    'statusEl.className="status show "+type;statusEl.innerHTML=msg}'
                    'async function handleRetry(){'
                    'retryBtn.disabled=true;'
                    'retryBtn.innerHTML=\'<span class="spinner"></span>æ­£åœ¨ä¿®å¤...\';'
                    'showStatus("â³ æ­£åœ¨æ£€æŸ¥è¯­æ³•å¹¶å°è¯•è‡ªåŠ¨ä¿®å¤...","info");'
                    'try{const r=await fetch("/api/retry",{method:"POST"});'
                    'const d=await r.json();'
                    'if(d.success){'
                    'showStatus("âœ… "+d.message+"<br>é¡µé¢å°†åœ¨ 3 ç§’åè‡ªåŠ¨åˆ·æ–°...","success");'
                    'setTimeout(()=>location.reload(),3000)'
                    '}else{'
                    'showStatus("âŒ "+d.message,"error");'
                    'retryBtn.disabled=false;retryBtn.innerHTML="ğŸ”§ é‡è¯•ä¿®å¤"}'
                    '}catch(e){'
                    'showStatus("âŒ è¯·æ±‚å¤±è´¥: "+e.message,"error");'
                    'retryBtn.disabled=false;retryBtn.innerHTML="ğŸ”§ é‡è¯•ä¿®å¤"}}'
                    'async function handleDiagnose(){'
                    'diagnoseBtn.disabled=true;diagnoseBtn.innerHTML="ğŸ” æ£€æŸ¥ä¸­...";'
                    'try{const r=await fetch("/api/diagnose");const d=await r.json();'
                    'let info="<b>ğŸ“‹ è¯Šæ–­ç»“æœ</b><br>";'
                    'info+="Python: "+d.python_version+"<br>";'
                    'info+="app.py å­˜åœ¨: "+(d.app_file_exists?"âœ…":"âŒ")+"<br>";'
                    'info+="æ–‡ä»¶å¤§å°: "+(d.app_file_size/1024).toFixed(1)+" KB<br>";'
                    'info+="è¯­æ³•æ£€æŸ¥: "+(d.syntax_ok?"âœ… é€šè¿‡":"âŒ "+d.syntax_error)+"<br>";'
                    'showStatus(info,d.syntax_ok?"success":"error")'
                    '}catch(e){showStatus("âŒ è¯Šæ–­å¤±è´¥: "+e.message,"error")}'
                    'diagnoseBtn.disabled=false;diagnoseBtn.innerHTML="ğŸ” è¯Šæ–­æ£€æŸ¥"}'
                    '</script></body></html>'
                )

            def log_message(self, fmt, *args):
                pass  # é™é»˜æ—¥å¿—

        server = HTTPServer((KOTO_HOST, port), FallbackHandler)
        _write_log(f"âš ï¸ é”™è¯¯æ¢å¤æœåŠ¡å™¨å·²å¯åŠ¨åœ¨ http://{KOTO_HOST}:{port}")
        server.serve_forever()
    except Exception as fallback_err:
        _write_log(f"âŒ é”™è¯¯æ¢å¤æœåŠ¡å™¨ä¹Ÿæ— æ³•å¯åŠ¨: {fallback_err}")

def create_system_tray(window_ref=None):
    """åˆ›å»ºç³»ç»Ÿæ‰˜ç›˜å›¾æ ‡"""
    try:
        from pystray import Icon, Menu, MenuItem
        from PIL import Image, ImageDraw
        icon_file = APP_ROOT / "assets" / "koto_icon.png"

        def create_icon_image():
            """åˆ›å»ºç®€å•çš„æ‰˜ç›˜å›¾æ ‡"""
            # åˆ›å»º 64x64 å›¾æ ‡
            width, height = 64, 64
            image = Image.new('RGBA', (width, height), (0, 0, 0, 0))
            draw = ImageDraw.Draw(image)
            
            # ç»˜åˆ¶åœ†å½¢èƒŒæ™¯ - æ¸å˜è“è‰²
            draw.ellipse([4, 4, 60, 60], fill=(66, 133, 244, 255))
            
            # ç»˜åˆ¶å†…éƒ¨åœ†å½¢ - ç™½è‰²
            draw.ellipse([16, 16, 48, 48], fill=(255, 255, 255, 255))
            
            # ç»˜åˆ¶ "è¨€" å­—å½¢çŠ¶çš„ç®€åŒ–ç‰ˆæœ¬ - ä¸‰æ¡æ¨ªçº¿
            draw.rectangle([22, 24, 42, 28], fill=(66, 133, 244, 255))
            draw.rectangle([22, 32, 42, 36], fill=(66, 133, 244, 255))
            draw.rectangle([22, 40, 42, 44], fill=(66, 133, 244, 255))
            
            return image

        def on_quit(icon, item):
            """é€€å‡ºåº”ç”¨"""
            icon.stop()
            os._exit(0)

        def on_show(icon, item):
            """æ˜¾ç¤ºä¸»çª—å£"""
            if window_ref:
                try:
                    window_ref[0].show()
                except:
                    pass

        def on_hide(icon, item):
            """éšè—ä¸»çª—å£"""
            if window_ref:
                try:
                    window_ref[0].hide()
                except:
                    pass

        # åˆ›å»ºæ‰˜ç›˜å›¾æ ‡ï¼ˆä¼˜å…ˆä½¿ç”¨è‡ªå®šä¹‰å›¾æ ‡ï¼‰
        if icon_file.exists():
            tray_image = Image.open(str(icon_file))
        else:
            tray_image = create_icon_image()

        icon = Icon(
            "Koto",
            tray_image,
            "Koto - AI åŠ©æ‰‹ (è¿è¡Œä¸­)",
            Menu(
                MenuItem("æ˜¾ç¤ºçª—å£", on_show, default=True),
                MenuItem("éšè—çª—å£", on_hide),
                Menu.SEPARATOR,
                MenuItem("é€€å‡º", on_quit)
            )
        )

        return icon
    except Exception as e:
        print(f"âš ï¸ ç³»ç»Ÿæ‰˜ç›˜åˆ›å»ºå¤±è´¥: {e}")
        return None

def main():
    """ä¸»å…¥å£ - æ¡Œé¢åº”ç”¨æ¨¡å¼"""
    # åˆå§‹åŒ–
    ensure_directories()
    check_config()
    if not ensure_dependencies():
        return
    _write_log("ğŸš€ å¯åŠ¨ Koto æ¡Œé¢ç¨‹åº")

    # ç”Ÿæˆé»˜è®¤å›¾æ ‡ï¼ˆå¦‚ç¼ºå¤±ï¼‰
    try:
        from PIL import Image, ImageDraw
        icon_dir = APP_ROOT / "assets"
        icon_dir.mkdir(exist_ok=True, parents=True)
        ico_path = icon_dir / "koto_icon.ico"
        png_path = icon_dir / "koto_icon.png"

        if not png_path.exists():
            width, height = 256, 256
            image = Image.new('RGBA', (width, height), (0, 0, 0, 0))
            draw = ImageDraw.Draw(image)
            draw.rounded_rectangle([0, 0, 256, 256], radius=56, fill=(79, 140, 255, 255))
            draw.ellipse([48, 48, 208, 208], fill=(255, 255, 255, 255))
            draw.rectangle([72, 88, 184, 104], fill=(47, 107, 255, 255))
            draw.rectangle([72, 120, 184, 136], fill=(47, 107, 255, 255))
            draw.rectangle([72, 152, 184, 168], fill=(47, 107, 255, 255))
            image.save(str(png_path))

        if not ico_path.exists():
            image = Image.open(str(png_path))
            image.save(str(ico_path), sizes=[(256, 256), (128, 128), (64, 64), (32, 32), (16, 16)])
    except Exception as e:
        _write_log(f"âš ï¸ ç”Ÿæˆé»˜è®¤å›¾æ ‡å¤±è´¥: {e}")

    # å¯¼å…¥ webview
    import webview
    _write_log("âœ” å·²å¯¼å…¥ webview")

    # å¯åŠ¨åç«¯
    server_info = start_flask_server() or {}
    app_url = f"http://{KOTO_HOST}:{KOTO_PORT}"
    health_url = f"{app_url}/api/health"
    if server_info.get("error"):
        _write_log(f"âš ï¸ Flask çº¿ç¨‹æŠ¥é”™: {server_info['error']}")
    if server_info.get("already_running"):
        _write_log("â„¹ï¸ å‘ç°å·²æœ‰åç«¯è¿è¡Œï¼Œå¤ç”¨å®ƒ")

    # å¦‚æœç«¯å£è¢«å¤–éƒ¨ç¨‹åºå ç”¨ä¸”ä¸å¥åº·ï¼Œç›´æ¥åˆ‡æ¢å¤‡ç”¨ç«¯å£
    if server_info.get("needs_fallback"):
        err_msg = (
            "æ£€æµ‹åˆ° 5000 ç«¯å£è¢«å…¶ä»–ç¨‹åºå ç”¨ä¸”å“åº”å¼‚å¸¸ï¼Œè‡ªåŠ¨åˆ‡æ¢å¤‡ç”¨ç«¯å£ 5001ã€‚\n"
            "è¯·å…³é—­å ç”¨ 5000 ç«¯å£çš„ç¨‹åºï¼Œæˆ–ä½¿ç”¨å¤‡ç”¨ç«¯å£è®¿é—®ã€‚"
        )
        _write_log(err_msg)
        threading.Thread(
            target=_start_fallback_server,
            args=(err_msg, FALLBACK_PORT),
            daemon=True
        ).start()
        app_url = f"http://{KOTO_HOST}:{FALLBACK_PORT}"
    else:
        # ç­‰å¾…åç«¯å°±ç»ª
        if not _wait_for_port(KOTO_HOST, KOTO_PORT, STARTUP_TIMEOUT_SEC):
            err_msg = "åç«¯æœåŠ¡å¯åŠ¨è¶…æ—¶ï¼Œè¯·æ£€æŸ¥ä¾èµ–æˆ–ç«¯å£å ç”¨æƒ…å†µã€‚"
            _write_log(err_msg)
            _dump_threads("wait-port-timeout")
            threading.Thread(
                target=_start_fallback_server,
                args=(err_msg, KOTO_PORT),
                daemon=True
            ).start()
        else:
            _write_log("âœ” åç«¯ç«¯å£å·²å°±ç»ª")

    # === å¿«é€Ÿå¯åŠ¨æ¨¡å¼ï¼šè·³è¿‡é¢„çƒ­æ£€æŸ¥ ===
    # pywebview å†…éƒ¨ä¼šå¤„ç†åŠ è½½è¶…æ—¶ï¼Œæ— éœ€æå‰æ£€æŸ¥
    _write_log("âš¡ å¿«é€Ÿå¯åŠ¨ï¼šè·³è¿‡é¢„çƒ­æ£€æŸ¥ï¼Œç›´æ¥åˆ›å»ºçª—å£")

    # é€‰æ‹©çª—å£å›¾æ ‡ï¼ˆå¦‚å­˜åœ¨ï¼‰
    icon_path = None
    ico_path = APP_ROOT / "assets" / "koto_icon.ico"
    if ico_path.exists():
        icon_path = str(ico_path)

    # åˆ›å»ºæ¡Œé¢çª—å£
    window = webview.create_window(
        title='Koto - AI ä¸ªäººåŠ©æ‰‹',
        url=app_url,
        width=1200,
        height=800,
        resizable=True,
        fullscreen=False,
        min_size=(400, 300),
        confirm_close=False,
        text_select=True,
        easy_drag=False,  # å…³é—­æ‹–æ‹½æ¨¡å¼ï¼Œé˜²æ­¢æ‹¦æˆªç‚¹å‡»äº‹ä»¶
        on_top=False  # ä¸ç½®é¡¶ï¼Œè®©ç”¨æˆ·æ­£å¸¸ä½¿ç”¨
    )
    
    if icon_path:
        _write_log(f"âœ” å›¾æ ‡è·¯å¾„: {icon_path}")
    _write_log(f"âœ” åˆ›å»ºçª—å£ï¼ŒåŠ è½½ {app_url}")

    # ç»‘å®šçª—å£æ§åˆ¶API
    window_api = WindowAPI(window)
    window.expose(window_api.switch_to_mini)
    window.expose(window_api.switch_to_full)
    window.expose(window_api.get_mode)
    window.expose(window_api.minimize)
    window.expose(window_api.maximize)
    window.expose(window_api.close)

    # çª—å£å¼•ç”¨ï¼ˆä¾›æ‰˜ç›˜ä½¿ç”¨ï¼‰
    window_ref = [window]

    # åˆ›å»ºç³»ç»Ÿæ‰˜ç›˜ï¼ˆåœ¨å•ç‹¬çº¿ç¨‹ä¸­ï¼‰
    tray_icon = create_system_tray(window_ref)
    if tray_icon:
        tray_thread = threading.Thread(target=tray_icon.run, daemon=True)
        tray_thread.start()
        _write_log("âœ” ç³»ç»Ÿæ‰˜ç›˜çº¿ç¨‹å·²å¯åŠ¨")

    # â”€â”€ å¯åŠ¨é˜¶æ®µçœ‹é—¨ç‹— â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # webview.start() ä¼šæ°¸ä¹…é˜»å¡ä¸»çº¿ç¨‹ï¼ˆè¿™æ˜¯æ­£å¸¸è¡Œä¸ºï¼Œå®ƒå°±æ˜¯çª—å£äº‹ä»¶å¾ªç¯ï¼‰ã€‚
    # çœ‹é—¨ç‹—ä»…ç›‘æ§ã€Œçª—å£æ˜¯å¦åœ¨è¶…æ—¶å†…æˆåŠŸæ˜¾ç¤ºã€ï¼Œä¸€æ—¦ on_shown è§¦å‘å°±å–æ¶ˆã€‚
    # é¿å…ä¹‹å‰çš„ bugï¼š35ç§’åæ— æ¡ä»¶ os._exit æ€æ‰æ­£åœ¨æ­£å¸¸è¿è¡Œçš„ç¨‹åºã€‚
    _window_shown = threading.Event()

    def on_shown():
        """çª—å£æ˜¾ç¤ºåçš„å›è°ƒ"""
        _window_shown.set()           # é€šçŸ¥çœ‹é—¨ç‹—ï¼šçª—å£å·²åŠ è½½
        _write_log("âœ” çª—å£å·²æ˜¾ç¤ºï¼Œåº”ç”¨æ­£å¸¸è¿è¡Œä¸­")

    def _startup_watchdog(timeout_sec: int = 45):
        """å¯åŠ¨çœ‹é—¨ç‹—ï¼šå¦‚æœçª—å£åœ¨ timeout_sec å†…æœªæ˜¾ç¤ºï¼Œè®°å½•è¯Šæ–­ä¿¡æ¯ã€‚
        æ³¨æ„ï¼šåªè®°å½•æ—¥å¿— + thread dumpï¼Œä¸å¼ºåˆ¶é€€å‡ºã€‚
        å¼ºåˆ¶é€€å‡ºä¼šå¯¼è‡´ç”¨æˆ·çœ‹åˆ°"é—ªé€€"ï¼Œä¸å¦‚è®©çª—å£ç»§ç»­å°è¯•åŠ è½½ã€‚"""
        if _window_shown.wait(timeout=timeout_sec):
            return  # çª—å£æ­£å¸¸æ˜¾ç¤ºï¼Œçœ‹é—¨ç‹—é€€å‡º
        # è¶…æ—¶ï¼šçª—å£æ²¡æœ‰æ˜¾ç¤º
        _write_log(f"âš ï¸ çª—å£åœ¨ {timeout_sec} ç§’å†…æœªæ˜¾ç¤ºï¼Œè®°å½•è¯Šæ–­ä¿¡æ¯")
        _dump_threads("startup-watchdog-timeout")
        # ä¸è°ƒç”¨ os._exit()ï¼Œè®©ç¨‹åºç»§ç»­å°è¯•

    watchdog = threading.Thread(target=_startup_watchdog, args=(45,), daemon=True)
    watchdog.start()

    _write_log("ğŸš€ å¯åŠ¨ webview.startï¼ˆçª—å£äº‹ä»¶å¾ªç¯ï¼‰")
    
    # åœ¨å¯åŠ¨æ—¶è®¾ç½®å›¾æ ‡ï¼ˆä»…Windowsæ”¯æŒï¼‰
    start_kwargs = {'func': on_shown, 'debug': False}
    if icon_path:
        start_kwargs['icon'] = icon_path
        _write_log(f"âœ” è®¾ç½®åº”ç”¨å›¾æ ‡: {icon_path}")
    
    webview.start(**start_kwargs)
    _write_log("â„¹ï¸ webview.start ç»“æŸï¼ˆçª—å£å·²å…³é—­ï¼‰")

    # çª—å£å…³é—­åé€€å‡º
    os._exit(0)

if __name__ == "__main__":
    main()
